---
title: "sandbox"
author: "Austin Nuckols"
date: "2/16/2020"
output: html_document
---

# Testing ground for all equations, etc.



```{r message=FALSE}
library(tidyverse)
```

## Binding

### One site total binding

How do I want to build out a binding function?

Starting with One Site Total binding

y = Bmax* X/(Kd + X) + NS*X + Background

Bmax is the maximum specific binding in arbitrary units
X is the concentration of ligand
Kd is the equilibrium binding constant

Let's make starting values to test with

```{r}
bmax <- 1000
kd <- 50
x <- c(10, 30, 100, 300, 1000)
```


```{r}
simbindone <- function(x, bmax, kd) {
  y = bmax*x/(kd + x)
}

(simbindone(c(10, 30, 100, 300), bmax, Kd))

#simple function works
```

Let's leave out the error for now

In the future, *make error a function of the binding where we expect ~10-20% of binding to be found nonspecifically*

```{r}
simbindone <- function(x, bmax, kd, cv, reps) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  return(values)
}

simbindone(x, bmax, kd, 0.1, 5) #this all works. great!
```

Test for full function?

```{r}

simbindone <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    ggplot2::geom_smooth(
      method=minpack.lm::nlsLM,
      formula = "y ~bmax*x/(x+kd)",
      method.args = list(
        start=c(bmax=bmax,
                kd=kd)
      ),
      se=F,
      color="blue"
    )
}

simbindone(x, bmax, kd, 0.01, 5, log = T)
simbindone(x, 1200, 50, 0.01, 5, log = T)

```

Let's work on the log error

Pseudocode: after assigning values, derive a model using the log transform, then store the coefficients into start and import start in the nlsLM call

```{r}
simbindone <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      #print(model)
      start <- list(bmax=exp(stats::coef(model)[1]), kd=exp(stats::coef(model))[2])
      #print(start)
      model <- nls(y ~ bmax * x/(kd + x), data = values, start = start)
      #print(model)
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    ggplot2::geom_smooth(
      method=minpack.lm::nlsLM,
      formula = "y ~bmax*x/(x+kd)",
      method.args = list(
        start= if (log){
          start} else {
            c(bmax = bmax,
          kd = kd)
        }
      ),
      se=F,
      color="blue"
    )
}

simbindone(x, bmax, kd, 0.01, 5, log = T) #so it still fails to plot the log = T line although my loop is in fact working and correctly predicting the nonlinear parameters despite log dosing
```

Copied from https://stats.stackexchange.com/questions/160552/why-is-nls-giving-me-singular-gradient-matrix-at-initial-parameter-estimates 

Used to determine parameters for nls functions

```{r}
q24 <- read.table(text = "reductions  cost.per.car
    50  45
    55  55
    60  62
    65  70
    70  80
    75  90
    80  100
    85  200
    90  375
    95  600
    ",header = TRUE, sep = "")

c.0 <- min(q24$cost.per.car) * 0.5
model.0 <- lm(log(cost.per.car - c.0) ~ reductions, data=q24)
start <- list(a=exp(coef(model.0)[1]), b=coef(model.0)[2], c=c.0)
model <- nls(cost.per.car ~ a * exp(b * reductions) + c, data = q24, start = start)

model.0
model
start

```

Script for generating parameter values using nls to then plug in for the minpack.lm::nlsLM call

```{r}
simbindone <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      #print(model)
      start <- list(bmax=exp(stats::coef(model)[1]), kd=exp(stats::coef(model))[2])
      #print(start)
      model <- nls(y ~ bmax * x/(kd + x), data = values, start = start)
      #print(str(model))
      here <- model$m$getPars()
      print(here)
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    if (log) {
      ggplot2::geom_smooth(
        method = minpack.lm::nlsLM,
         formula = "y ~bmax*x/(x+kd)",
          method.args = list(
          start = here),
          color = "blue")
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~bmax*x/(x+kd)",
        method.args = list(
          start= c(bmax = bmax,
            kd = kd)
        ),
        se=F,
        color="blue")
      }
}

simbindone(x, bmax, kd, 0.01, 5, log = F)
simbindone(x, bmax, kd, 0.01, 5, log = T) #This does not work. 

```

Maybe we just need to keep it to  method = auto

This works, but clearly this is imperfect

```{r}
simbindone <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      #print(model)
      start <- list(bmax=exp(stats::coef(model)[1]), kd=exp(stats::coef(model))[2])
      #print(start)
      model <- nls(y ~ bmax * x/(kd + x), data = values, start = start)
      #print(str(model))
      here <- model$m$getPars()
      print(here)
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    if (log) {
      ggplot2::geom_smooth(
        method = stats::loess,
        formula = "y ~ x",
        color = "blue",
        se = F)
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~bmax*x/(x+kd)",
        method.args = list(
          start= c(bmax = bmax,
            kd = kd)
        ),
        se=F,
        color="blue")
      }
}

simbindone(x, bmax, kd, 0.01, 5, log = F)
simbindone(x, bmax, kd, 0.1, 5, log = T) #This looks really bad as you increase the cv

```

Try with a stat_function call

```{r}
simbindone <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      #print(model)
      start <- list(bmax=exp(stats::coef(model)[1]), kd=exp(stats::coef(model))[2])
      #print(start)
      model <- nls(y ~ bmax * x/(kd + x), data = values, start = start)
      #print(str(model))
      here <- model$m$getPars()
      print(here)
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    if (log) {
      ggplot2::stat_function(geom = "smooth", fun = function(x) y = bmax*10^x/(kd + 10^x),
          color = "blue")
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~bmax*x/(x+kd)",
        method.args = list(
          start= c(bmax = bmax,
            kd = kd)
        ),
        se=F,
        color="blue")
      }
}

simbindone(x, bmax, kd, 0.01, 5, log = F)
simbindone(x, bmax, kd, 0.1, 5, log = T) 
simbindone(x, 10000, 200, 0.5, 5, log = T) # IT WORKS AND APPEARS TO BE CONSISTENT
```

Let's clean it up so that it only has the necessary components

```{r}
sim1sbind <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    if (log) {
      ggplot2::stat_function(geom = "smooth", fun = function(x) y = bmax*10^x/(kd + 10^x),
          color = "blue")
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~bmax*x/(x+kd)",
        method.args = list(
          start= c(bmax = bmax,
            kd = kd)
        ),
        se=F,
        color="blue")
      }
}

sim1sbind(x, bmax, kd, 0.1, 5, log = F)
```

Let's update this:

right now, the stat_function call is just plotting an exact line for the input values of bmax and kd. It is not responding to the variability of the chosen points. 

I can use the log-values work around to force nls to generate parameters, and then make the stat_function call graph those

```{r}
sim1sbind <- function(x, bmax, kd, cv, reps, log=F) {
  
  y = bmax*x/(kd + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      start <- list(bmax=exp(stats::coef(model)[1]), kd=exp(stats::coef(model))[2])
      model <- stats::nls(y ~ bmax * x/(kd + x), data = values, start = start)
      bmax.var <- model$m$getPars()[1]
      kd.var <- model$m$getPars()[2]
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y=bmax*x/(x+kd)") +
    if (log) {
      ggplot2::stat_function(geom = "smooth", fun = function(x) y = bmax.var*10^x/(kd.var + 10^x),
          color = "blue")
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~bmax*x/(x+kd)",
        method.args = list(
          start= c(bmax = bmax,
            kd = kd)
        ),
        se=F,
        color="blue")
      }
}

sim1sbind(x, bmax, kd, 0.1, 5, log = T) 
sim1sbind(x, 10000, 200, 0.5, 5, log = T)
```



## Kinetics

### Michaelis-menten equation - just to start

So on Prism, they split this into 3 kinds of equations. They include just a regular mic-menten, a way to calculate turnover^, and a way to consider allosteric modulation. They're all the same equation, so I might as well wrap them into one

y = Vmax * x^h/(Km^h + x)
Vmax = Et * kcat

Update: I am having trouble getting the function to return Vmax to me such that it can be used. It's made to 

If h = 1, then there is no allosteric modulation, and curve is purely hyperbolic. If h > 1, then it becomes sigmoidal. If h = 1, then Et or kcat can be derived from Vmax by dividing Vmax by the other of those two parameters

```{r}
simmicmenten <- function(x, vmax, km, h = 1, cv, reps, log=F) {
  
  y = vmax*x^h/(km^h + x)
  
  values <- data.frame(x=rep(x, reps), y)
  
  values <- dplyr::mutate(values, y=apply(values, 1, function(x) stats::rnorm(1, x[2], cv*x[2])))
  
  for (i in 1) {
    if (log) {
      model <- stats::lm(log(y) ~ log(x), data=values)
      print(model)
      start <- list(vmax=exp(stats::coef(model)[1]), km=exp(stats::coef(model))[2])
      print(start)
      model <- stats::nls(y ~ vmax * x^h/(km^h + x), data = values, start = start)
      vmax.var <- model$m$getPars()[1]
      km.var <- model$m$getPars()[2]
      print(model)
      break
    } else {break}
  }
  
  ggplot2::ggplot(
    values,
    ggplot2::aes(x=if (log){
      log10(x)} else {
        x}, y)) +
    ggplot2::geom_point(size=2) +
    ggplot2::labs(title="model: y = vmax*x^h/(km^h + x)") +
    if (log) {
      ggplot2::stat_function(geom = "smooth", fun = function(x) y = vmax.var*10^x^h/(km.var^h + 10^x),
          color = "blue")
    } else {
      ggplot2::geom_smooth(
        method=minpack.lm::nlsLM,
        formula = "y ~vmax*x^h/(x+km^h)",
        method.args = list(
          start= c(vmax = vmax,
            km = km,
            h = h)
        ),
        se=F,
        color="blue")
      }
}

x <- c(10, 30, 100, 300, 1000, 3000, 10000, 30000)

simmicmenten(x, bmax, kd, h=1, 0.1, 5, log = F) 
simmicmenten(x, 10000, 200, 0.5, 5, h =1, log = T)
simmicmenten(x, 10000, 100, h = 1.5, 0.1, 5, log = F)
simmicmenten(x, 1000, 100, cv = 0.1, reps = 5)

test <- simmicmenten(x, 10000, 100, h = 1.5, 0.1, 5, log = F)
#test$mapping
```

```{r}
#I'll write a function for fun below that's meant to calculate the Vmax (via average)
snatch <- function(model) {
  model$data %>% summarise(vmax = mean(
    model$data %>% group_by(x) %>% filter(x[max(x) == T])
  ))
}

snatch(test)
```

